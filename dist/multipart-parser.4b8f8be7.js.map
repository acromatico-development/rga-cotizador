{"mappings":"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","sources":["node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"names":[],"version":3,"file":"multipart-parser.4b8f8be7.js.map"}